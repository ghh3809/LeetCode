第1次提交：分析这是一道典型的深度优先搜索。建立Stack存储当前搜索的状态，同时利用deepCopy函数将当前状态进行复制。效果不佳。
第2次提交：受到讨论区启发，考虑共享当前的搜索状态。既然需要共享board的状态，就需要实时记录当前搜索状态，当结果不正确时再将其回溯。这里用了一个trick：在入栈下一步搜索状态之前，首先入栈一个指示栈，意味着如果出栈到当前位置时，就需要对这个位置的元素进行复原操作。利用board记录的时候，采用board^=256的方法将其转为不可识别字符，以达到目的。这样做效果并不好，说明时间消耗主要不是在deepCopy上。
第3次提交：老老实实采用递归的方法写dfs。同样利用异或256的方法保存状态，否则还需要传递visited数组。