第1次提交：利用递推的思想，逐步增加数量，维护一个递增数组，平均复杂度O(nlogn)，但最坏复杂度O(n^2)。最终在最坏复杂度情况下TLE。
第2次提交：O(n)复杂度，依赖于一个较难理解的证明：若由a(x)、a(y)两个数组成的容积最大，那么当左指针到达a(x)之前(即某一算法确定的最大a(1)位置)时，右指针不可能在a(y)左侧(即某一算法确定的最大a(2)位置)（位置图：a(1)->a(x)->a(2)->a(y)）
解题注意：两指针移动过程中，最大值逐渐增大。
反证：假定a(1) < a(2)且算法认为这两处为最大位置 => 左指针到达a(1)位置时，右指针到达a(2)位置 => （1）要么左指针到达a(1)，而右指针在a(2)右侧；（2）要么右指针到达a(2)，左指针到达a(1)左侧 => （1）为了使得右指针移动，需要使得右指针的数比左指针小。即意味着a(2)右侧的数要小于a(1)，即有a(y) < a(1)；（2）为了使得左指针移动，需要使得左指针的数比右指针小，即a(1)左侧的数小于a(2)。事实上，a(1)左侧的数也必须小于a(1)，否则假如a(1)左侧的某一a(0) > a(1)，则a(0)a(2)组成的才是最大值，与题设矛盾。而又由于a(2)又是由a(y)左移得到，因此a(y)必小于a(1)左侧的某数，因此a(y) < a(0) < a(1); => a(y) < a(1)时，a(x)a(y) < a(1)a(y)，因此x和y必然不是最大值的位置。
最终说明：如果x和y为真正的最大位置，而1和2为算法认为的最大位置，则二者不可能交叉。证毕。